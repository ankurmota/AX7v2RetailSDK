/**
 * SAMPLE CODE NOTICE
 * 
 * THIS SAMPLE CODE IS MADE AVAILABLE AS IS.  MICROSOFT MAKES NO WARRANTIES, WHETHER EXPRESS OR IMPLIED,
 * OF FITNESS FOR A PARTICULAR PURPOSE, OF ACCURACY OR COMPLETENESS OF RESPONSES, OF RESULTS, OR CONDITIONS OF MERCHANTABILITY.
 * THE ENTIRE RISK OF THE USE OR THE RESULTS FROM THE USE OF THIS SAMPLE CODE REMAINS WITH THE USER.
 * NO TECHNICAL SUPPORT IS PROVIDED.  YOU MAY NOT DISTRIBUTE THIS CODE UNLESS YOU HAVE A LICENSE AGREEMENT WITH MICROSOFT THAT ALLOWS YOU TO DO SO.
 */

module Commerce.Proxy.Requests {
    "use strict";

    /**
     * Represents a chained data service request object.
     */
    export class ChainedRequest implements Common.IDataServiceRequest {
        private static TOKEN_API_NAME: string = "token";
        private static AUTHENTICATION_ENTITY_TYPE: string = "Authentication";
        private static STARTSESSION_API_NAME: string = "StartSession";
        private static SHIFT_ENTITY_NAME: string = "shifts";
        private static CLOSESHIFT_API_NAME: string = "close";
        private static BLINDCLOSESHIFT_API_NAME: string = "blindclose";
        private static SUSPENDSHIFT_API_NAME: string = "suspend";
        private static RESUMESHIFT_API_NAME: string = "resume";

        private _query: Common.IDataServiceQueryInternal;
        private _chainedRequestFactory: ChainedRequestFactory;
        private _onlineDataServiceRequestFactory: Common.IDataServiceRequestFactory;
        private _offlineDataServiceRequestFactory: Common.IDataServiceRequestFactory;
        private _request: Common.IDataServiceRequest;
        private _locale: string;
        private onlineDictionary: any;
        private offlineDictionary: any;
        private offlineSyncDownloadDictionary: any;

        /**
         * Gets the Request Identifier.
         * Autogenerated unique identifier if executed in batch. Used to fetch the response from batch result array.
         */
        public id(): number {
            return this._request.id();
        }

        /**
         * Gets the locale for current request.
         */
        public get locale(): string {
            return this._locale;
        }

        /**
         * Sets the locale for current request.
         */
        public set locale(locale: string) {
            this._locale = locale;
        }

        constructor(onlineDataServiceRequestFactory: Common.IDataServiceRequestFactory,
            offlineDataServiceRequestFactory: Common.IDataServiceRequestFactory,
            chainedRequestFactory: ChainedRequestFactory,
            query: Common.IDataServiceQueryInternal,
            locale: string = "") {
            this._query = query;
            this._onlineDataServiceRequestFactory = onlineDataServiceRequestFactory;
            this._offlineDataServiceRequestFactory = offlineDataServiceRequestFactory;
            this._chainedRequestFactory = chainedRequestFactory;
            this._locale = locale;

            // Maintains a dictionary to record actions which are online specific.
            this.onlineDictionary = new Commerce.Dictionary();
            this.onlineDictionary.setItem("GetDownloadInterval", true);
            this.onlineDictionary.setItem("GetDownloadSessions", true);
            this.onlineDictionary.setItem("GetDownloadLink", true);
            this.onlineDictionary.setItem("GetTerminalDataStoreName", true);
            this.onlineDictionary.setItem("GetUploadJobDefinitions", true);
            this.onlineDictionary.setItem("GetUploadInterval", true);
            this.onlineDictionary.setItem("PostOfflineTransactions", true);
            this.onlineDictionary.setItem("UpdateDownloadSession", true);

            // Maintains a dictionary to record actions which are offline specific.
            this.offlineDictionary = new Commerce.Dictionary();
            this.offlineDictionary.setItem("GetOfflineSyncStatus", true);
            this.offlineDictionary.setItem("GetOfflinePendingTransactionCount", true);

            // Maintains a dictionary to record actions which are offline data download API.
            this.offlineSyncDownloadDictionary = new Commerce.Dictionary();
            this.offlineSyncDownloadDictionary.setItem("GetTerminalDataStoreName", true);
            this.offlineSyncDownloadDictionary.setItem("GetDownloadInterval", true);
            this.offlineSyncDownloadDictionary.setItem("GetDownloadSessions", true);
            this.offlineSyncDownloadDictionary.setItem("GetDownloadLink", true);
            this.offlineSyncDownloadDictionary.setItem("UpdateDownloadSession", true);
        }

        /**
         * Execute the request.
         * @return {IAsyncResult<T>} The async result.
         */
        public execute<T>(): IAsyncResult<T> {
            var asyncResult: AsyncResult<T>;
            var result: T;

            if (this.isOfflineRequest()) {
                return this.executeOfflineRequest<T>();
            }

            var queue: AsyncQueue = new AsyncQueue();
            queue.enqueue(() => {
                // If request is authentication request, do not attempt to transfer shift to online.
                // If request is related to offline sync data download, do not transfer shift to online to make sure
                // this is not called twice when both download and upload sync requests trigger this. 
                if (this._query.entityType !== ChainedRequest.AUTHENTICATION_ENTITY_TYPE && this._query.action !== ChainedRequest.STARTSESSION_API_NAME
                    && !this.isOfflineSyncDownloadRequest()) {
                    return this._chainedRequestFactory.switchConnectionToOnlineIfDue();
                } else {
                    return VoidAsyncResult.createResolved();
                }
            });

            queue.enqueue(() => {
                if (Session.instance.connectionStatus !== ConnectionStatusType.Online && !this.isOnlineRequest()
                    && !this.isLogOnRequest()) {
                    asyncResult = <AsyncResult<T>>this.executeOfflineRequest<T>(true);
                } else {
                    asyncResult = new AsyncResult<T>();
                    var isLogOnRequest: boolean = this.isLogOnRequest();

                    this.executeOnlineRequest<T>()
                        .done((result: T) => {

                            // For authentication requests when connected to RS, repeat the request for offline data source.
                            if ((isLogOnRequest || (this.isLogOffRequest() && Session.instance.isOfflineAvailable))
                                && Commerce.StringExtensions.isNullOrWhitespace(Commerce.Config.onlineDatabase)) {

                                // Repeat request with no transaction Logging
                                if (isLogOnRequest) {
                                    if ((Commerce.Config.offlineDatabase !== null) && (Commerce.Config.offlineDatabase.length !== 0)) {
                                        this.incrementTransactionIdOnRequest();

                                        // we need to wait until offline acquireToken call is done before
                                        // returning to the caller that the API call was completed
                                        // this is because, if the online counterpart call is faster, then we might perform the offline calls out of order
                                        // leading to unexpected behavior in offline mode
                                        this.executeOfflineLogonRequest().always((): void => {
                                            if (this._query.action === ChainedRequest.TOKEN_API_NAME) {
                                                asyncResult.resolve(result);
                                            }
                                        });

                                        if (this._query.action !== ChainedRequest.TOKEN_API_NAME) {
                                            asyncResult.resolve(result);
                                        }
                                    } else {
                                        asyncResult.resolve(result);
                                    }
                                } else {
                                    this.incrementTransactionIdOnRequest();
                                    this.executeOfflineRequest<T>()
                                        .done((result: T) => {
                                            if (!this.offlineDictionary.getItem(this._query.action)) {
                                                Session.instance.isOfflineAvailable = true;
                                            }
                                        }).fail((error: Model.Entities.Error[]) => {
                                            Session.instance.isOfflineAvailable = false;
                                        });

                                    asyncResult.resolve(result);
                                }
                            } else {
                                asyncResult.resolve(result);
                            }
                        }).fail((errors: Entities.Error[]) => {
                            var error: Model.Entities.Error = ArrayExtensions.firstOrUndefined(errors);

                            // If retail server is not available while logon in offline mode, only execute logon request in offline without switching.
                            if (error && error.ErrorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE
                                && Commerce.Session.instance.connectionStatus !== ConnectionStatusType.Online
                                && this.isLogOnRequest()) {
                                this.executeOfflineRequest<T>(true)
                                    .done((result: T) => {
                                        asyncResult.resolve(result);
                                    }).fail((errors: Model.Entities.Error[]) => {
                                        asyncResult.reject(errors);
                                    });
                            } else if (error && error.ErrorCode === ErrorTypeEnum.SERVICE_UNAVAILABLE
                                && Commerce.Session.instance.connectionStatus === ConnectionStatusType.Online) {
                                // If data source is not available, then switch offline if available.
                                var asyncQueue: AsyncQueue = new AsyncQueue();
                                var result: T;
                                // Logon request must be executed before switching the connection, otherwise shift/cart transfer will fail.
                                if (!isLogOnRequest) {
                                    asyncQueue.enqueue(() => {
                                        return this._chainedRequestFactory.switchConnection(ConnectionStatusType.SeamlessOffline, false);
                                    });
                                }

                                asyncQueue.enqueue(() => {
                                    // If the request is not online only request, execute offline request.
                                    if (!this.isOnlineRequest()) {
                                        return this.executeOfflineRequest<T>(true)
                                            .done((data: T) => {
                                                if (!this.offlineDictionary.getItem(this._query.action)) {
                                                    Session.instance.isOfflineAvailable = true;
                                                }
                                                result = data;
                                            }).fail((requestErrors: Model.Entities.Error[]) => {
                                                errors = requestErrors;
                                            });
                                    } else {
                                        return VoidAsyncResult.createRejected();
                                    }
                                });

                                if (isLogOnRequest) {
                                    asyncQueue.enqueue(() => {
                                        return this._chainedRequestFactory.switchConnection(ConnectionStatusType.SeamlessOffline, false);
                                    });
                                }

                                asyncQueue.run()
                                    .done(() => asyncResult.resolve(result))
                                    .fail(() => asyncResult.reject(errors));
                            } else {
                                asyncResult.reject(errors);
                            }
                        });
                }

                return asyncResult
                    .done((asyncResult: T) => { result = asyncResult; });
            });

            return queue.run().map(() => {
                return result;
            });
        }

        /**
         * Executes the batch requests.
         * @param {DataServiceRequest[]} requests The collection of requests to execute.
         * @return {IAsyncResult<Array>} The async result.  Responses at index I correlates to request with identifier I.
         */
        public executeBatch(requests: Common.IDataServiceRequest[]): IAsyncResult<any[]> {
            var batchRequests: Common.IDataServiceRequest[] = [];
            var factory: Common.IDataServiceRequestFactory = this._onlineDataServiceRequestFactory;

            if (Session.instance.connectionStatus !== ConnectionStatusType.Online) {
                factory = this._offlineDataServiceRequestFactory;
            }

            requests.forEach((request: ChainedRequest) => {
                request._request = factory.create(request._query);
                batchRequests.push(request._request);
            });

            return this._request.executeBatch(batchRequests);
        }

        private executeOnlineRequest<T>(): IAsyncResult<T> {
            this._request = this._onlineDataServiceRequestFactory.create(this._query);

            return this._request.execute();
        }

        private executeOfflineRequest<T>(keepReqeustInstance?: boolean): IAsyncResult<T> {
            var request: Common.IDataServiceRequest = this._offlineDataServiceRequestFactory.create(this._query);

            if (keepReqeustInstance) {
                this._request = request;
            }

            return request.execute();
        }

        private isLogOnRequest(): boolean {
            return (ObjectExtensions.isNullOrUndefined(this._query.entitySet)
                && (this._query.action.toLowerCase() === "startsession" || this._query.action.toLowerCase() === ChainedRequest.TOKEN_API_NAME));
        }

        private isLogOffRequest(): boolean {
            return (ObjectExtensions.isNullOrUndefined(this._query.entitySet) && (this._query.action.toLowerCase() === "endsession"));
        }

        private isOnlineRequest(): boolean {
            if (!ObjectExtensions.isNullOrUndefined(this._query.entitySet)) {
                // For the following shift related API, it should be marked as online only.
                if (this._query.entitySet.toLowerCase() === ChainedRequest.SHIFT_ENTITY_NAME
                    && (this._query.action.toLowerCase() === ChainedRequest.CLOSESHIFT_API_NAME
                        || this._query.action.toLowerCase() === ChainedRequest.BLINDCLOSESHIFT_API_NAME ||
                        this._query.action.toLowerCase() === ChainedRequest.SUSPENDSHIFT_API_NAME
                        || this._query.action.toLowerCase() === ChainedRequest.RESUMESHIFT_API_NAME)) {
                    return true;
                } else {
                    return false;
                }
            } else {
                if (this.onlineDictionary.getItem(this._query.action)) {
                    return true;
                } else {
                    return false;
                }
            }
        }

        private isOfflineRequest(): boolean {
            if (!ObjectExtensions.isNullOrUndefined(this._query.entitySet)) {
                return false;
            }

            var isOffline: boolean = false;

            if (this.offlineDictionary.getItem(this._query.action)) {
                isOffline = true;
            }

            return isOffline;
        }

        private isOfflineSyncDownloadRequest(): boolean {
            return (ObjectExtensions.isNullOrUndefined(this._query.entitySet) && (this.offlineSyncDownloadDictionary.getItem(this._query.action)));
        }

        private executeOfflineLogonRequest<T>(): IVoidAsyncResult {
            return this.executeOfflineRequest<T>()
                .done((result: T) => {
                    if (!this.offlineDictionary.getItem(this._query.action)) {
                        Session.instance.isOfflineAvailable = true;
                    }
                }).fail((error: Model.Entities.Error[]) => {
                    Session.instance.isOfflineAvailable = false;
                });
        }

        private incrementTransactionIdOnRequest(): void {
            if (this._query.data && this._query.data.parameters && this._query.data.parameters.transactionId) {
                this._query.data.parameters.transactionId = NumberSequence.GetNextTransactionId();
            }
        }
    }
}