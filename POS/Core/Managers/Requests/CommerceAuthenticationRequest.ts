/**
 * SAMPLE CODE NOTICE
 * 
 * THIS SAMPLE CODE IS MADE AVAILABLE AS IS.  MICROSOFT MAKES NO WARRANTIES, WHETHER EXPRESS OR IMPLIED,
 * OF FITNESS FOR A PARTICULAR PURPOSE, OF ACCURACY OR COMPLETENESS OF RESPONSES, OF RESULTS, OR CONDITIONS OF MERCHANTABILITY.
 * THE ENTIRE RISK OF THE USE OR THE RESULTS FROM THE USE OF THIS SAMPLE CODE REMAINS WITH THE USER.
 * NO TECHNICAL SUPPORT IS PROVIDED.  YOU MAY NOT DISTRIBUTE THIS CODE UNLESS YOU HAVE A LICENSE AGREEMENT WITH MICROSOFT THAT ALLOWS YOU TO DO SO.
 */

module Commerce.Proxy.Requests {
    "use strict";

    /**
     *  Class for commerce authentication requests.
     */
    export class CommerceAuthenticationRequest implements Common.IDataServiceRequest {
        private static DEVICE_TOKEN_NAME: string = "DeviceToken";
        private static AUTHENTICATION_TOKEN_NAME: string = "Authorization";
        private static PARAMETER_SEPARATOR: string = "&";
        private static PARAMETER_KEY_VALUE_SEPARATOR: string = "=";
        private static TOKEN_API_NAME: string = "token";
        private static OPERATION_ID_NAME: string = "operation_id";
        private endpointUri: string;
        private apiName: string;
        private data: any;
        private dataType: string;


        constructor(endpointUri: string, dataServiceQuery: Common.IDataServiceQueryInternal) {
            this.endpointUri = endpointUri;
            this.apiName = dataServiceQuery.action;
            this.data = dataServiceQuery.data || {};
            this.dataType = dataServiceQuery.dataType;
        }

        /**
         * Locale for the current request.
         */
        public get locale(): string {
            return "";
        }

        /**
         * Request Identifier.
         * Autogenerated unique identifier if executed in batch. Used to fetch the response from batch result array.
         */
        public id(): number {
            throw new Error("Not supported.");
        }

        /**
         * Execute the request.
         * @return {IAsyncResult<T>} The async result.
         */
        public execute<T>(): IAsyncResult<T> {
            var url: string = StringExtensions.format("{0}/{1}", this.endpointUri, this.apiName);
            var headers: { [headerName: string]: string } = {};
            var data: T = null;

            return new AsyncQueue().enqueue((): IVoidAsyncResult => {
                // Add device token to the header
                return Authentication.AuthenticationProviderManager.instance.acquireToken(Authentication.AuthenticationProviderResourceType.DEVICE)
                    .done((authenticationToken: Authentication.IAuthenticationToken): void => {
                    if (!ObjectExtensions.isNullOrUndefined(authenticationToken)) {
                        headers[CommerceAuthenticationRequest.DEVICE_TOKEN_NAME] = authenticationToken.token;
                    }
                });
            }).enqueue((): IVoidAsyncResult => {
                // we need to be authenticated for non token api or manager override
                if (this.apiName.toLowerCase() !== CommerceAuthenticationRequest.TOKEN_API_NAME
                    || !StringExtensions.isNullOrWhitespace(this.data[CommerceAuthenticationRequest.OPERATION_ID_NAME])) {
                    return Authentication.AuthenticationProviderManager.instance.acquireToken(Authentication.AuthenticationProviderResourceType.USER)
                        .done((token: Authentication.IAuthenticationToken): void => {
                            if (!ObjectExtensions.isNullOrUndefined(token) && !StringExtensions.isNullOrWhitespace(token.token)) {
                            headers[CommerceAuthenticationRequest.AUTHENTICATION_TOKEN_NAME] = StringExtensions.format("{0} {1}", token.tokenType, token.token);
                        }
                    });
                }

                return VoidAsyncResult.createResolved();
                }).enqueue((): IVoidAsyncResult => {

                if (!ObjectExtensions.isNullOrUndefined(this.dataType)) {
                    headers[Common.HttpHeaders.CONTENT_TYPE] = this.dataType;
                }

                var result: VoidAsyncResult = new VoidAsyncResult();
                var body: string = this.getRequestBody();
                var request: Common.IXmlHttpRequest = {
                    requestUri: url,
                    body: body,
                    headers: headers,
                    method: Common.HttpVerbs.POST
                };

                Common.XmlHttpRequestHelper.executeRequest(request,
                    (response: Common.IXmlHttpResponse): void => {
                        if (response.statusCode !== Common.HttpStatusCodes.NO_CONTENT) {
                            data = <T>JSON.parse(response.body);
                        }
                        result.resolve();
                    }, (error: Common.IXmlHttpError): void => {
                        var errors: Model.Entities.Error[] = Context.ErrorParser.parseErrorMessage(error.response);

                        // Handles authentication related errors, if any.
                        ErrorHandler.authenticationErrorHandler(errors);

                        result.reject(errors);
                    });

                return result;
            }).run().map((): T => {
                return data;
            });
        }

        /**
         * Executes the batch requests.
         * @param {IDataServiceRequest[]} requests The collection of requests to execute.
         * @return {IAsyncResult<any[]>} The async result. Responses at index I correlates to request with identifier I.
         */
        public executeBatch(requests: Common.IDataServiceRequest[]): IAsyncResult<any[]> {
            throw new Error("Not supported.");
        }

        /**
         * Gets the request body from based on the request paramters.
         * @returns {string} the request body.
         */
        private getRequestBody(): string {

            if (Common.MimeTypes.areSame(Common.MimeTypes.APPLICATION_JSON, this.dataType)) {
                return this.convertToJson(this.data);
            } else {
                return this.convertToFormUrlEncoded(this.data);
            }
        }

        private convertToJson(data: any): string {
            return JSON.stringify(data);
        }

        private convertToFormUrlEncoded(data: any): string {
            var bodyParameters: string[] = [];

            ObjectExtensions.forEachKeyValuePair(data, (key: string, value: string): void => {
                if (!ObjectExtensions.isNullOrUndefined(value)) {
                    bodyParameters.push(StringExtensions.format("{0}{1}{2}", key, CommerceAuthenticationRequest.PARAMETER_KEY_VALUE_SEPARATOR, value));
                }
            });

            var body: string = bodyParameters.join(CommerceAuthenticationRequest.PARAMETER_SEPARATOR);
            return body;
        }
    }
} 