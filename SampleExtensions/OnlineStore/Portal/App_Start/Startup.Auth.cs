/**
 * SAMPLE CODE NOTICE
 * 
 * THIS SAMPLE CODE IS MADE AVAILABLE AS IS.  MICROSOFT MAKES NO WARRANTIES, WHETHER EXPRESS OR IMPLIED,
 * OF FITNESS FOR A PARTICULAR PURPOSE, OF ACCURACY OR COMPLETENESS OF RESPONSES, OF RESULTS, OR CONDITIONS OF MERCHANTABILITY.
 * THE ENTIRE RISK OF THE USE OR THE RESULTS FROM THE USE OF THIS SAMPLE CODE REMAINS WITH THE USER.
 * NO TECHNICAL SUPPORT IS PROVIDED.  YOU MAY NOT DISTRIBUTE THIS CODE UNLESS YOU HAVE A LICENSE AGREEMENT WITH MICROSOFT THAT ALLOWS YOU TO DO SO.
 */

namespace Contoso
{
    namespace Retail.Ecommerce.Web.Storefront
    {
        using System;
        using System.Configuration;
        using System.Threading.Tasks;
        using Microsoft.Owin;
        using Microsoft.Owin.Security;
        using Microsoft.Owin.Security.Cookies;
        using Microsoft.Owin.Security.OpenIdConnect;
        using global::Owin;
        using Retail.Ecommerce.Sdk.Core;

        /// <summary>
        /// Represents the startup class for the web application.
        /// </summary>
        public partial class Startup
        {
            /// <summary>
            /// Configures the authentication.
            /// </summary>
            /// <param name="app">The application.</param>
            public void ConfigureAuth(IAppBuilder app)
            {
                app.UseCookieAuthentication(new CookieAuthenticationOptions
                {
                    AuthenticationType = CookieConstants.ApplicationCookieAuthenticationType,
                    LoginPath = new PathString("/SignIn"),
                    CookieSecure = CookieSecureOption.Always
                });

                app.SetDefaultSignInAsAuthenticationType(CookieAuthenticationDefaults.AuthenticationType);

                // Loading Retail Configuration to access available Identity Providers.
                RetailConfigurationSection retailConfiguration = (RetailConfigurationSection)ConfigurationManager.GetSection(OpenIdConnectUtilities.ConfigurationSectionName);

                // Enumerating all available Identity Providers and creating a middleware for each of the provider.
                foreach (IdentityProviderClientConfigurationElement provider in retailConfiguration.IdentityProviders)
                {
                    if (provider.ProviderType == IdentityProviderType.OpenIdConnect)
                    {
                        OpenIdConnectAuthenticationOptions options = GetOpenIdConnectAuthenticationOptions(provider);
                        app.UseOpenIdConnectAuthentication(options);
                    }
                }
            }

            private static OpenIdConnectAuthenticationOptions GetOpenIdConnectAuthenticationOptions(IdentityProviderClientConfigurationElement provider)
            {
                OpenIdConnectAuthenticationOptions options = new OpenIdConnectAuthenticationOptions
                {
                    AuthenticationType = provider.Name,
                    Caption = provider.Name,
                    ClientId = provider.ClientId,
                    Authority = provider.Issuer.ToString(),
                    RedirectUri = provider.RedirectUrl.ToString(),

                    // Leveraging Authorization Code grant
                    ResponseType = "code",
                    Scope = "openid email",
                    Notifications = GetOpenIdConnectAuthenticationNotifications()
                };

                return options;
            }

            /// <summary>
            /// Gets the open identifier connect authentication notifications.
            /// </summary>
            /// <returns>The open identifier authentication notifications.</returns>
            private static OpenIdConnectAuthenticationNotifications GetOpenIdConnectAuthenticationNotifications()
            {
                return new OpenIdConnectAuthenticationNotifications
                {
                    RedirectToIdentityProvider = (context) =>
                    {
                    // Trimming an autogenerated (by Katana) Nonce to avoid encrypted id_token length to exceed 4K (the maximum value could be stored in a cookie) 
                    // because the token is stored in Forms Auth cookie.
                    // If other approaches are used to store the token then consider removing the line below which trims the Nonce.
                    context.ProtocolMessage.Nonce = context.ProtocolMessage.Nonce.Substring(0, 20);

                    // By default Katana uses form_post mode which is currently supported by very few providers, such as AAD
                    // so, overwriting the default value with "query" which is supported by a bigger amount of providers
                    context.ProtocolMessage.ResponseMode = "query";

                        CookieOptions shortLivingCookieOptions = new CookieOptions { Expires = DateTime.UtcNow.AddMinutes(5), HttpOnly = true, Secure = true };
                        context.OwinContext.Response.Cookies.Append(OpenIdConnectUtilities.CookieState, context.ProtocolMessage.State, shortLivingCookieOptions);
                        context.OwinContext.Response.Cookies.Append(OpenIdConnectUtilities.CookieNonce, context.ProtocolMessage.Nonce, shortLivingCookieOptions);

                    // Storing currently used Provider in a longer living cookie because the provider is needed at LogOut time.
                    CookieOptions longLivingCookieOptions = new CookieOptions { Expires = DateTime.MaxValue, HttpOnly = true, Secure = true };
                        context.OwinContext.Response.Cookies.Append(OpenIdConnectUtilities.CookieCurrentProvider, context.Options.AuthenticationType, longLivingCookieOptions);

                        return Task.FromResult(0);
                    }
                };
            }
        }
    }
}